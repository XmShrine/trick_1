<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>四轨音游</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
        }

        #leftPanel {
            width: 200px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 100;
        }

        #scoreDisplay {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 18px;
            z-index: 100;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }

        #judgmentDisplay {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            min-height: 30px;
        }

        .miss { color: #ff4444; }
        .good { color: #44ff44; }
        .perfect { color: #ffff44; }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #delayCalibration {
            border-top: 1px solid #333;
            padding-top: 15px;
            margin-top: 10px;
        }

        #delaySliderContainer {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        #playTestBtn {
            background: #444;
            color: #fff;
            border: 2px solid #666;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
            margin-bottom: 10px;
            disabled: true;
        }

        #playTestBtn:hover:not(:disabled) {
            background: #666;
            border-color: #888;
        }

        #playTestBtn:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
            border-color: #444;
        }

        #delaySlider {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        #delaySlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
        }

        #delaySlider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        #delayValue {
            text-align: center;
            font-size: 14px;
            color: #ccc;
        }

        #clickIndicator {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            font-weight: bold;
            color: #ffff44;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 16px;
            border-radius: 5px;
            border: 1px solid #ffff44;
            display: none;
            z-index: 200;
        }

        button {
            background: #333;
            color: #fff;
            border: 1px solid #666;
            padding: 10px;
            border-radius: 3px;
            cursor: pointer;
            font-family: monospace;
        }

        button:hover {
            background: #555;
        }

        button:disabled {
            background: #222;
            color: #666;
            cursor: not-allowed;
        }

        #gameArea {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #tracks {
            position: absolute;
            right: 0;
            top: 0;
            width: 320px;
            height: 100vh;
            display: flex;
        }

        .track {
            flex: 1;
            position: relative;
            border-left: 1px solid #333;
            background: linear-gradient(180deg, transparent 0%, rgba(255,255,255,0.1) 85%, rgba(255,255,255,0.2) 100%);
        }

        .track:last-child {
            border-right: 1px solid #333;
        }

        .hitZone {
            position: absolute;
            bottom: 80px;
            left: 5px;
            right: 5px;
            height: 60px;
            border: 2px solid #fff;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
        }

        .note {
            position: absolute;
            left: 5px;
            right: 5px;
            height: 40px;
            background-image: url('source.jpeg');
            background-size: cover;
            background-position: center;
            border-radius: 8px;
            border: 1px solid #fff;
            opacity: 0.8;
        }

        .keyButton {
            position: absolute;
            bottom: 10px;
            left: 5px;
            right: 5px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid #fff;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
        }

        .keyButton:active,
        .keyButton.pressed {
            background: rgba(255,255,255,0.5);
            transform: scale(0.95);
        }

        #progressBar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: #333;
        }

        #progressFill {
            height: 100%;
            background: #fff;
            width: 0%;
            transition: width 0.1s;
        }

        /* Mobile styles */
        @media (max-width: 768px) {
            #leftPanel {
                width: 150px;
                padding: 10px;
                font-size: 12px;
            }

            #scoreDisplay {
                font-size: 14px;
                padding: 5px;
            }

            #tracks {
                width: calc(100vw - 150px);
            }

            .keyButton {
                height: 80px;
                font-size: 16px;
            }

            .hitZone {
                bottom: 90px;
            }

            #judgmentDisplay {
                font-size: 18px;
            }
        }

        @media (max-height: 600px) {
            .keyButton {
                height: 60px;
            }
            
            .hitZone {
                bottom: 70px;
            }
        }

        /* Game Over Screen */
        #gameOverScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameOverPanel {
            background: #000;
            border: 2px solid #fff;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            font-family: monospace;
        }

        #gameOverTitle {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 30px;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #finalScoreDisplay {
            font-size: 24px;
            margin-bottom: 20px;
            color: #fff;
        }

        #finalScoreNumber {
            font-size: 48px;
            font-weight: bold;
            color: #ffff44;
            margin: 10px 0;
        }

        #accuracyDisplay {
            font-size: 18px;
            margin-bottom: 30px;
            color: #ccc;
        }

        .statsGrid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .statItem {
            text-align: center;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.05);
        }

        .statLabel {
            font-size: 12px;
            color: #999;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .statValue {
            font-size: 20px;
            font-weight: bold;
        }

        .statValue.perfect { color: #ffff44; }
        .statValue.good { color: #44ff44; }
        .statValue.miss { color: #ff4444; }

        .gameOverButtons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .gameOverBtn {
            background: #333;
            color: #fff;
            border: 2px solid #666;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-family: monospace;
            font-size: 14px;
            text-transform: uppercase;
            transition: all 0.2s;
        }

        .gameOverBtn:hover {
            background: #555;
            border-color: #888;
        }

        .gameOverBtn.primary {
            background: #444;
            border-color: #fff;
        }

        .gameOverBtn.primary:hover {
            background: #666;
        }

        @media (max-width: 768px) {
            #gameOverPanel {
                padding: 30px 20px;
            }
            
            #gameOverTitle {
                font-size: 24px;
            }
            
            #finalScoreNumber {
                font-size: 36px;
            }
            
            .statsGrid {
                gap: 10px;
            }
            
            .statItem {
                padding: 10px;
            }
            
            .gameOverButtons {
                flex-direction: column;
                gap: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="leftPanel">
            <div id="judgmentDisplay"></div>
            <div id="controls">
                <div id="delayCalibration">
                    <button id="calibrateBtn" onclick="toggleCalibration()">调整延迟</button>
                    <div id="delaySliderContainer">
                        <button id="playTestBtn" onclick="playTest()" disabled>播放</button>
                        <input type="range" id="delaySlider" min="-500" max="500" value="0" oninput="updateDelay(this.value)">
                        <div id="delayValue">延迟: 0ms</div>
                    </div>
                </div>
                <button id="startBtn" onclick="startGame()">开始游戏</button>
                <button id="pauseBtn" onclick="togglePause()" disabled>暂停</button>
                <button id="restartBtn" onclick="restartGame()" disabled>重新开始</button>
            </div>
            <div id="stats">
                <div>Perfect: <span id="perfectCount">0</span></div>
                <div>Good: <span id="goodCount">0</span></div>
                <div>Miss: <span id="missCount">0</span></div>
            </div>
        </div>

        <div id="gameArea">
            <div id="scoreDisplay">
                <span id="currentScore">0</span> / <span id="maxScore">10000</span>
            </div>
            
            <div id="tracks">
                <div class="track" data-track="0">
                    <div class="hitZone"></div>
                    <div class="keyButton" data-key="0">D</div>
                </div>
                <div class="track" data-track="1">
                    <div class="hitZone"></div>
                    <div class="keyButton" data-key="1">F</div>
                </div>
                <div class="track" data-track="2">
                    <div class="hitZone"></div>
                    <div class="keyButton" data-key="2">J</div>
                </div>
                <div class="track" data-track="3">
                    <div class="hitZone"></div>
                    <div class="keyButton" data-key="3">K</div>
                </div>
            </div>

            <div id="progressBar">
                <div id="progressFill"></div>
            </div>
        </div>
        
        <div id="clickIndicator">Click</div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
        <div id="gameOverPanel">
            <div id="gameOverTitle">Game Over</div>
            
            <div id="finalScoreDisplay">
                <div>Final Score</div>
                <div id="finalScoreNumber">0</div>
                <div id="maxScoreText">/ 10000</div>
            </div>
            
            <div id="accuracyDisplay">
                Accuracy: <span id="accuracyPercent">0</span>%
            </div>
            
            <div class="statsGrid">
                <div class="statItem">
                    <div class="statLabel">Perfect</div>
                    <div class="statValue perfect" id="finalPerfect">0</div>
                </div>
                <div class="statItem">
                    <div class="statLabel">Good</div>
                    <div class="statValue good" id="finalGood">0</div>
                </div>
                <div class="statItem">
                    <div class="statLabel">Miss</div>
                    <div class="statValue miss" id="finalMiss">0</div>
                </div>
            </div>
            
            <div class="gameOverButtons">
                <button class="gameOverBtn primary" onclick="playAgain()">Play Again</button>
                <button class="gameOverBtn" onclick="backToMenu()">Menu</button>
            </div>
        </div>
    </div>

    <script>
        // Game configuration
        const clickTime = [4465,5094,5925,6947,7739,8584,9057,10249,10767,11565,13112,14006,14809,16073,16272,16453,16629,16808,17025,17213,17361,17567,17768,17953,18281,18668,19072,19456,19832,20435,20637,20816,21016,21402,21833,22223,22625,23018,23728,23891,24072,24213,24662,25028,25444,25860,26257,26872,27088,27334,27538,28153,28423,28855,29096,29907,30193,30425,30634,31040,31481,31862,32240,32607,33304,33497,33680,33919,34233,34632,35032,35410,35826,36488,36704,36929,37342,37834,38278,38638,39086,39260,39464,39815,40038,40272,40662,40853,41092,41473,41703,41921,42295,42687,43082,43393,43769,44025,44136,44359,44536,44735,44928,45091,45520,45764,45871,45959,46096,46224,46400,46646,47032,47301,47410,47501,47656,47831,47993,48177,48346,48685,49054,49289,49593,49878,50319,50619,50712,50810,50944,51135,51316,51478,51927,52136,52289,52393,52511,52600,52774,52960,53129,53529,53686,53830,53945,54067,54200,54321,54508,54711,55073,55486,55730,56018,56299,56617,56752,56896,57051,57198,57330,57481,57571,57787,57920,58136,58400,58577,58695,58814,58976,59146,59352,59510,59905,60133,60244,60472,60609,60794,60985,61175,61505,61832,62062,62385,62691,63119,63400,63511,63776,63903,64073,64215,64382,64818,64962,65071,65241,65375,65527,65754,65956,66327,66530,66671,66806,67047,67217,67368,67589,68058,68480,68794,69288,69432,69692,69887,70106,70303,70519,70714,70935,71127,71357,71562,71766,71945,72168,72346,72537,72736,72924,73089,73324,73510,73709,73874,74088,74269,74503,74689,74928,75112,75321,75481,75704,75862,76082,76245,76486,76654,76891,77055,77281,77455,77657,77866,78070,78230,78460,78644,78864,79083,79231,79394,79498,79614,79776,79951,80144,80390,80592,80824,81049,81302,81693,82136,82287,82570,82788,83016,83202,83455,83896,84105,84282,84416,84592,84829,85008,85178,85503,85751,85872,85986,86146,86353,86536,86722,86919,87400,87704,88062,88287,88793,88970,89097,89239,89348,89527,89694,89877,90363,90509,90648,90837,91032,91224,91445,91835,92118,92239,92348,92490,92615,92785,92998,93151,93567,93848,94145,94424,94784,95125,95267,95383,95476,95599,95752,95966,96152,96330,96793,96920,97066,97217,97394,97568,97784,97947,98339,98494,98669,98880,99080,99293,99488,99720,99934,100141,100336,100515,100851,101105,101516,101673,101889,102008,102100,102242,102351,102514,102692,102872,103222,103331,103470,103584,103737,103886,104007,104165,104330,104710,104878,105015,105122,105249,105486,105616,105807,106210,106392,106594,106784,107107,107455,107824,108093,108275,108435,108549,108702,108814,108983,109192,109552,109768,109942,110047,110144,110272,110413,110560,110736,111154,111338,111472,111586,111841,111951,112116,112294,112466,112812,113081,113327,113627,113915,114433,114714,114874,114976,115113,115250,115389,115566,115977,116207,116328,116430,116546,116662,116843,117017,117442,117681,117814,117911,118025,118136,118306,118441,118608,118780,119091,119641,119978,120423,120853,120958,121085,121204,121355,121601,121805,121975,122367,122613,122739,122847,122982,123126,123312,123489,123904,124318,124455,124705,124921,125135,125320,125706,125883,126126,126442,126681,127083,127248,127462,127666,127875,128100,128288,128518,128697,128924,129103,129312,129503,129707,129904,130134,130329,130543,130705,130931,131128,131353,131539,131752,131948,132157,132368,132556,132921,133318,133633,138275,138811,139638,141247,142046,142791,144942,145450]; // Example timing data
        const timeLen = 149000; // Example max time
        const NOTE_SPEED = 600; // pixels per second (可调节的下落速度)
        
        // Delay calibration configuration
        const lateRange = 1000; // 延迟调整范围 ±500ms
        let lateTime = 0; // 当前延迟时间
        const testClick = [964]; // 测试音频的关键帧
        const testTime = 964; // "Click"提示出现的时间
        const testdurTime = 500; // "Click"提示持续时间
        
        // Calculate fall distance and time once
        let FALL_DISTANCE = 0;
        let FALL_TIME = 0;
        
        // Delay calibration state
        let calibrationState = {
            isActive: false,
            isPlaying: false,
            audio: null,
            startTime: 0,
            clickIndicator: null,
            testNote: null,
            testNoteSpawned: false
        };
        
        // Game state
        let gameState = {
            isPlaying: false,
            isPaused: false,
            startTime: 0,
            currentTime: 0,
            score: 0,
            maxScore: 10000,
            pointsPerNote: 0,
            notes: [],
            stats: { perfect: 0, good: 0, miss: 0 }
        };

        // Audio elements
        let gameAudio = null;
        let pushAudio = null;

        // Game elements
        const tracks = document.querySelectorAll('.track');
        const keyButtons = document.querySelectorAll('.keyButton');
        const judgmentDisplay = document.getElementById('judgmentDisplay');
        const currentScoreEl = document.getElementById('currentScore');
        const progressFill = document.getElementById('progressFill');

        // Initialize game
        function initGame() {
            // Create audio elements
            gameAudio = new Audio('audio.m4a');
            pushAudio = new Audio('push.m4a');
            calibrationState.audio = new Audio('test.m4a');
            
            // Setup calibration audio loop
            calibrationState.audio.addEventListener('ended', () => {
                // Reset for next play (but don't auto-play)
                calibrationState.isPlaying = false;
                calibrationState.testNoteSpawned = false;
                if (calibrationState.testNote && calibrationState.testNote.element) {
                    calibrationState.testNote.element.remove();
                }
                calibrationState.testNote = null;
                document.getElementById('clickIndicator').style.display = 'none';
            });
            
            gameAudio.addEventListener('loadedmetadata', () => {
                const actualTimeLen = Math.min(timeLen, gameAudio.duration * 1000);
                console.log('Game duration:', actualTimeLen + 'ms');
            });

            // Calculate fall distance and time based on track layout
            calculateFallParameters();

            // Calculate points per note
            gameState.pointsPerNote = Math.floor(gameState.maxScore / clickTime.length);
            
            // Generate notes with calculated spawn times
            generateNotes();
            
            // Setup controls
            setupControls();
            
            // Update score display
            updateScoreDisplay();
            
            // Initialize delay slider
            updateDelaySliderRange();
        }

        function calculateFallParameters() {
            // Wait for DOM to be ready
            const trackHeight = window.innerHeight;
            const hitZoneBottom = 80; // Distance from bottom to hit zone center
            
            // Calculate fall distance: from top of track to hit zone
            FALL_DISTANCE = trackHeight - hitZoneBottom - 30; // 30px for hit zone height/2
            
            // Calculate fall time based on speed: distance / speed
            FALL_TIME = (FALL_DISTANCE / NOTE_SPEED) * 1000; // Convert to milliseconds
            
            console.log(`Fall distance: ${FALL_DISTANCE}px, Fall time: ${FALL_TIME}ms`);
        }

        function generateNotes() {
            gameState.notes = [];
            clickTime.forEach((hitTime, index) => {
                const track = Math.floor(Math.random() * 4); // Random track 0-3
                
                // Calculate spawn time: hit time minus fall time, adjusted for delay
                const spawnTime = hitTime - FALL_TIME - lateTime;
                
                gameState.notes.push({
                    id: index,
                    track: track,
                    hitTime: hitTime,        // When note should reach hit zone
                    spawnTime: spawnTime,    // When note should be created
                    element: null,
                    hit: false,
                    missed: false,
                    spawned: false
                });
            });
            
            console.log('Generated notes with spawn times:', gameState.notes.map(n => ({
                hitTime: n.hitTime,
                spawnTime: n.spawnTime,
                track: n.track
            })));
        }

        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (gameState.isPlaying && !gameState.isPaused) {
                    let keyIndex = -1;
                    switch(e.key.toLowerCase()) {
                        case 'd': keyIndex = 0; break;
                        case 'f': keyIndex = 1; break;
                        case 'j': keyIndex = 2; break;
                        case 'k': keyIndex = 3; break;
                    }
                    
                    if (keyIndex >= 0) {
                        hitKey(keyIndex);
                    }
                } else if (calibrationState.isActive) {
                    let keyIndex = -1;
                    switch(e.key.toLowerCase()) {
                        case 'd': keyIndex = 0; break;
                        case 'f': keyIndex = 1; break;
                        case 'j': keyIndex = 2; break;
                        case 'k': keyIndex = 3; break;
                    }
                    
                    if (keyIndex >= 0) {
                        hitTestKey(keyIndex);
                    }
                }
            });

            // Touch controls
            keyButtons.forEach((btn, index) => {
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (gameState.isPlaying && !gameState.isPaused) {
                        hitKey(index);
                    } else if (calibrationState.isActive) {
                        hitTestKey(index);
                    }
                });
                
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (gameState.isPlaying && !gameState.isPaused) {
                        hitKey(index);
                    } else if (calibrationState.isActive) {
                        hitTestKey(index);
                    }
                });
            });
        }

        function hitKey(keyIndex) {
            const keyButton = keyButtons[keyIndex];
            keyButton.classList.add('pressed');
            setTimeout(() => keyButton.classList.remove('pressed'), 100);

            // Check for hit notes
            const currentTime = gameState.currentTime;
            const trackNotes = gameState.notes.filter(note => 
                note.track === keyIndex && !note.hit && !note.missed && note.spawned
            );

            let bestNote = null;
            let bestDistance = Infinity;

            trackNotes.forEach(note => {
                const distance = Math.abs(note.hitTime - currentTime + lateTime); // Apply delay offset
                if (distance < bestDistance && distance < 200) { // 200ms judgment window
                    bestDistance = distance;
                    bestNote = note;
                }
            });

            if (bestNote) {
                bestNote.hit = true;
                if (bestNote.element) {
                    bestNote.element.remove();
                }

                let judgment;
                if (bestDistance < 50) {
                    judgment = 'perfect';
                    gameState.stats.perfect++;
                    gameState.score += gameState.pointsPerNote;
                } else if (bestDistance < 100) {
                    judgment = 'good';
                    gameState.stats.good++;
                    gameState.score += Math.floor(gameState.pointsPerNote * 0.7);
                } else {
                    judgment = 'good';
                    gameState.stats.good++;
                    gameState.score += Math.floor(gameState.pointsPerNote * 0.5);
                }

                showJudgment(judgment);
                playPushSound();
                updateStats();
            }
        }

        function showJudgment(judgment) {
            judgmentDisplay.textContent = judgment.toUpperCase();
            judgmentDisplay.className = judgment;
            setTimeout(() => {
                judgmentDisplay.textContent = '';
                judgmentDisplay.className = '';
            }, 1000);
        }

        function playPushSound() {
            if (pushAudio) {
                pushAudio.currentTime = 0;
                pushAudio.play().catch(e => console.log('Audio play failed:', e));
            }
        }

        function updateStats() {
            document.getElementById('perfectCount').textContent = gameState.stats.perfect;
            document.getElementById('goodCount').textContent = gameState.stats.good;
            document.getElementById('missCount').textContent = gameState.stats.miss;
            updateScoreDisplay();
        }

        function updateScoreDisplay() {
            currentScoreEl.textContent = gameState.score;
        }

        function startGame() {
            // Stop calibration if active
            if (calibrationState.isActive) {
                stopCalibration();
            }
            
            // Recalculate fall parameters in case window was resized
            calculateFallParameters();
            
            gameState.isPlaying = true;
            gameState.isPaused = false;
            gameState.startTime = Date.now();
            gameState.score = 0;
            gameState.stats = { perfect: 0, good: 0, miss: 0 };

            // Reset notes
            generateNotes();
            clearNotes();

            // Update UI
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('restartBtn').disabled = false;
            document.getElementById('calibrateBtn').disabled = true;

            // Start audio
            if (gameAudio) {
                gameAudio.currentTime = 0;
                gameAudio.play().catch(e => console.log('Audio play failed:', e));
            }

            // Start game loop
            gameLoop();
        }

        function togglePause() {
            if (!gameState.isPlaying) return;

            gameState.isPaused = !gameState.isPaused;
            const pauseBtn = document.getElementById('pauseBtn');

            if (gameState.isPaused) {
                pauseBtn.textContent = '继续';
                if (gameAudio) gameAudio.pause();
            } else {
                pauseBtn.textContent = '暂停';
                gameState.startTime = Date.now() - gameState.currentTime;
                if (gameAudio) gameAudio.play().catch(e => console.log('Audio play failed:', e));
                gameLoop();
            }
        }

        function restartGame() {
            gameState.isPlaying = false;
            gameState.isPaused = false;
            gameState.currentTime = 0;

            // Stop audio
            if (gameAudio) {
                gameAudio.pause();
                gameAudio.currentTime = 0;
            }

            // Clear notes
            clearNotes();

            // Reset UI
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = '暂停';
            document.getElementById('restartBtn').disabled = true;
            document.getElementById('calibrateBtn').disabled = false;

            // Reset display
            progressFill.style.width = '0%';
            judgmentDisplay.textContent = '';
            judgmentDisplay.className = '';
        }

        // Delay calibration functions
        function updateDelaySliderRange() {
            const slider = document.getElementById('delaySlider');
            slider.min = -lateRange;
            slider.max = lateRange;
            slider.value = lateTime;
            updateDelayDisplay();
        }

        function updateDelay(value) {
            lateTime = parseInt(value);
            updateDelayDisplay();
        }

        function updateDelayDisplay() {
            document.getElementById('delayValue').textContent = `延迟: ${lateTime}ms`;
        }

        function toggleCalibration() {
            if (calibrationState.isActive) {
                stopCalibration();
            } else {
                startCalibration();
            }
        }

        function startCalibration() {
            calibrationState.isActive = true;
            calibrationState.isPlaying = false;
            calibrationState.testNoteSpawned = false;
            calibrationState.testNote = null;
            
            // Update UI
            document.getElementById('calibrateBtn').textContent = '停止';
            document.getElementById('delaySliderContainer').style.display = 'flex';
            document.getElementById('playTestBtn').disabled = false;
            document.getElementById('startBtn').disabled = true;
            
            // Don't auto-start audio, wait for user to click play
        }

        function stopCalibration() {
            calibrationState.isActive = false;
            calibrationState.isPlaying = false;
            
            // Stop test audio
            if (calibrationState.audio) {
                calibrationState.audio.pause();
                calibrationState.audio.currentTime = 0;
            }
            
            // Clean up test note
            if (calibrationState.testNote && calibrationState.testNote.element) {
                calibrationState.testNote.element.remove();
            }
            calibrationState.testNote = null;
            calibrationState.testNoteSpawned = false;
            
            // Hide click indicator
            document.getElementById('clickIndicator').style.display = 'none';
            
            // Update UI
            document.getElementById('calibrateBtn').textContent = '调整延迟';
            document.getElementById('delaySliderContainer').style.display = 'none';
            document.getElementById('playTestBtn').disabled = true;
            document.getElementById('startBtn').disabled = false;
        }

        function playTest() {
            if (!calibrationState.isActive || calibrationState.isPlaying) return;
            
            // Reset previous test
            calibrationState.testNoteSpawned = false;
            if (calibrationState.testNote && calibrationState.testNote.element) {
                calibrationState.testNote.element.remove();
            }
            calibrationState.testNote = null;
            
            // Start test audio
            calibrationState.isPlaying = true;
            calibrationState.startTime = Date.now();
            
            if (calibrationState.audio) {
                calibrationState.audio.currentTime = 0;
                calibrationState.audio.play().catch(e => console.log('Test audio play failed:', e));
            }
            
            // Start calibration loop
            calibrationLoop();
        }

        function calibrationLoop() {
            if (!calibrationState.isActive || !calibrationState.isPlaying) return;
            
            const currentTime = Date.now() - calibrationState.startTime;
            const hitTime = testClick[0]; // Use the testClick timing
            
            // Generate test note
            if (!calibrationState.testNoteSpawned) {
                const spawnTime = hitTime - FALL_TIME - lateTime;
                if (currentTime >= spawnTime) {
                    spawnTestNote(hitTime);
                    calibrationState.testNoteSpawned = true;
                }
            }
            
            // Update test note position
            if (calibrationState.testNote && calibrationState.testNote.element) {
                updateTestNotePosition(currentTime);
            }
            
            // Show click indicator at specified time
            if (currentTime >= testTime && currentTime <= testTime + testdurTime) {
                document.getElementById('clickIndicator').style.display = 'block';
            } else {
                document.getElementById('clickIndicator').style.display = 'none';
            }
            
            requestAnimationFrame(calibrationLoop);
        }

        function spawnTestNote(hitTime) {
            // Choose a random track for the test note
            const randomTrack = Math.floor(Math.random() * 4);
            const track = tracks[randomTrack];
            
            const noteElement = document.createElement('div');
            noteElement.className = 'note';
            noteElement.style.top = '0px';
            
            track.appendChild(noteElement);
            
            calibrationState.testNote = {
                track: randomTrack,
                hitTime: hitTime,
                spawnTime: Date.now() - calibrationState.startTime,
                element: noteElement,
                hit: false,
                missed: false
            };
        }

        function updateTestNotePosition(currentTime) {
            if (!calibrationState.testNote || !calibrationState.testNote.element) return;
            
            const timeSinceSpawn = currentTime - calibrationState.testNote.spawnTime;
            const pixelsFromTop = (timeSinceSpawn / 1000) * NOTE_SPEED;
            const maxTop = FALL_DISTANCE;
            const noteTop = Math.min(pixelsFromTop, maxTop);
            
            calibrationState.testNote.element.style.top = noteTop + 'px';
            
            // Remove note if it's way past the hit zone or missed
            if (timeSinceSpawn > FALL_TIME + 1000 || currentTime > calibrationState.testNote.hitTime + 500) {
                calibrationState.testNote.element.remove();
                calibrationState.testNote = null;
            }
        }

        function clearNotes() {
            tracks.forEach(track => {
                const notes = track.querySelectorAll('.note');
                notes.forEach(note => note.remove());
            });
        }

        function gameLoop() {
            if (!gameState.isPlaying || gameState.isPaused) return;

            gameState.currentTime = Date.now() - gameState.startTime;
            const maxTime = Math.min(timeLen, gameAudio ? gameAudio.duration * 1000 : timeLen);

            // Update progress
            const progress = Math.min(gameState.currentTime / maxTime, 1);
            progressFill.style.width = (progress * 100) + '%';

            // Spawn notes based on calculated spawn time
            gameState.notes.forEach(note => {
                if (!note.spawned && !note.hit && !note.missed) {
                    if (gameState.currentTime >= note.spawnTime) {
                        spawnNote(note);
                        note.spawned = true;
                    }
                }
            });

            // Update note positions based on physics
            gameState.notes.forEach(note => {
                if (note.element && !note.hit && note.spawned) {
                    updateNotePosition(note);
                }
            });

            // Check for missed notes
            gameState.notes.forEach(note => {
                if (!note.hit && !note.missed && gameState.currentTime > note.hitTime + 200 - lateTime) {
                    note.missed = true;
                    gameState.stats.miss++;
                    if (note.element) {
                        note.element.remove();
                    }
                    showJudgment('miss');
                    updateStats();
                }
            });

            // Check for game end
            if (gameState.currentTime >= maxTime) {
                endGame();
                return;
            }

            requestAnimationFrame(gameLoop);
        }

        function spawnNote(note) {
            const track = tracks[note.track];
            const noteElement = document.createElement('div');
            noteElement.className = 'note';
            
            // Start at the top of the track
            noteElement.style.top = '0px';
            
            track.appendChild(noteElement);
            note.element = noteElement;
        }

        function updateNotePosition(note) {
            if (!note.element) return;

            const currentTime = gameState.currentTime;
            const timeSinceSpawn = currentTime - note.spawnTime;
            
            // Calculate position based on time since spawn and constant speed
            const pixelsFromTop = (timeSinceSpawn / 1000) * NOTE_SPEED; // pixels per second
            
            // Clamp position to track bounds
            const maxTop = FALL_DISTANCE;
            const noteTop = Math.min(pixelsFromTop, maxTop);
            
            note.element.style.top = noteTop + 'px';
            
            // Remove note if it's way past the hit zone (cleanup)
            if (timeSinceSpawn > FALL_TIME + 1000) { // 1 second grace period
                note.element.remove();
            }
        }

        function endGame() {
            gameState.isPlaying = false;
            
            // Stop audio
            if (gameAudio) {
                gameAudio.pause();
            }

            // Show game over screen
            showGameOverScreen();
        }

        function showGameOverScreen() {
            const totalNotes = clickTime.length;
            const hitNotes = gameState.stats.perfect + gameState.stats.good;
            const accuracy = totalNotes > 0 ? Math.round((hitNotes / totalNotes) * 100) : 0;

            // Update game over screen
            document.getElementById('finalScoreNumber').textContent = gameState.score;
            document.getElementById('accuracyPercent').textContent = accuracy;
            document.getElementById('finalPerfect').textContent = gameState.stats.perfect;
            document.getElementById('finalGood').textContent = gameState.stats.good;
            document.getElementById('finalMiss').textContent = gameState.stats.miss;

            // Show the screen
            document.getElementById('gameOverScreen').style.display = 'flex';
        }

        function hideGameOverScreen() {
            document.getElementById('gameOverScreen').style.display = 'none';
        }

        function playAgain() {
            hideGameOverScreen();
            restartGame();
            startGame();
        }

        function backToMenu() {
            hideGameOverScreen();
            restartGame();
        }

        // Initialize game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>